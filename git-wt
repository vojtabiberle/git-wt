#!/usr/bin/env bash
set -euo pipefail

# git-wt: Git worktree helper
# Add this directory to PATH, or: git config --global alias.wt '!git-wt'
# For cd support, source git-wt.sh in your .zshrc / .bashrc

readonly VERSION="1.0.0"

# Colors (stderr only)
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

info()  { echo -e "${GREEN}[wt]${NC} $*" >&2; }
warn()  { echo -e "${YELLOW}[wt]${NC} $*" >&2; }
error() { echo -e "${RED}[wt]${NC} $*" >&2; }

# ---------------------------------------------------------------------------
# Resolve repo root (works from worktrees too)
# ---------------------------------------------------------------------------
repo_root() {
    git rev-parse --show-toplevel 2>/dev/null \
        || { error "Not inside a git repository"; exit 1; }
}

main_repo_root() {
    local common_dir
    common_dir="$(git rev-parse --git-common-dir 2>/dev/null)"
    if [[ "$common_dir" == ".git" ]]; then
        repo_root
    else
        dirname "$common_dir"
    fi
}

# ---------------------------------------------------------------------------
# Configuration
# ---------------------------------------------------------------------------
load_config() {
    local root
    root="$(main_repo_root)"

    # Defaults
    WORKTREE_DIR=".."
    WORKTREE_PREFIX=""
    WORKTREE_SETUP=()

    # Auto-detect prefix from repo directory name
    local repo_name
    repo_name="$(basename "$root")"
    WORKTREE_PREFIX="$repo_name"

    # Source committed config
    if [[ -f "$root/worktree.conf" ]]; then
        # shellcheck disable=SC1091
        source "$root/worktree.conf"
    fi

    # Source local overrides
    if [[ -f "$root/worktree.conf.local" ]]; then
        # shellcheck disable=SC1091
        source "$root/worktree.conf.local"
    fi

    # Resolve WORKTREE_DIR relative to main repo root
    if [[ "$WORKTREE_DIR" != /* ]]; then
        WORKTREE_DIR="$(cd "$root" && cd "$WORKTREE_DIR" && pwd)"
    fi
}

# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------
sanitize_branch() {
    local branch="$1"
    echo "$branch" | tr '/' '-' | tr '[:upper:]' '[:lower:]'
}

worktree_path_for() {
    local branch="$1"
    local sanitized
    sanitized="$(sanitize_branch "$branch")"

    local dirname
    if [[ -n "$WORKTREE_PREFIX" ]]; then
        dirname="${WORKTREE_PREFIX}-${sanitized}"
    else
        dirname="$sanitized"
    fi

    echo "${WORKTREE_DIR}/${dirname}"
}

branch_exists() {
    git show-ref --verify --quiet "refs/heads/$1" 2>/dev/null
}

find_worktree_path() {
    local branch="$1"
    git worktree list --porcelain | awk -v branch="$branch" '
        /^worktree / { path = substr($0, 10) }
        /^branch refs\/heads\// {
            b = substr($0, 21)
            if (b == branch) { print path; exit }
        }
    '
}

current_worktree_branch() {
    local git_dir
    git_dir="$(git rev-parse --git-dir 2>/dev/null)"
    if [[ "$git_dir" != *".git/worktrees/"* ]]; then
        return 1
    fi
    git rev-parse --abbrev-ref HEAD 2>/dev/null
}

# ---------------------------------------------------------------------------
# Subcommands
# ---------------------------------------------------------------------------
cmd_add() {
    if [[ $# -lt 1 ]]; then
        error "Usage: git wt add <branch> [source-branch]"
        exit 1
    fi

    local branch="$1"
    local source="${2:-}"

    load_config

    local wt_path
    wt_path="$(worktree_path_for "$branch")"

    # Already exists?
    if [[ -d "$wt_path" ]]; then
        info "Worktree already exists at: $wt_path"
        echo "$wt_path"
        return 0
    fi

    # Create worktree
    if branch_exists "$branch"; then
        info "Branch '$branch' exists, checking out into worktree..."
        git worktree add "$wt_path" "$branch"
    else
        # Check if branch exists on origin when no source was specified
        if [[ -z "$source" ]] && git show-ref --verify --quiet "refs/remotes/origin/$branch" 2>/dev/null; then
            warn "Branch '$branch' not found locally, but exists on ${CYAN}origin${NC}."
            read -rp "Use origin/$branch? [Y/n] " answer
            if [[ "$answer" != [nN] ]]; then
                source="origin/$branch"
            fi
        fi

        if [[ -n "$source" ]]; then
            info "Creating branch '$branch' from '$source'..."
            git worktree add -b "$branch" "$wt_path" "$source"
        else
            info "Creating branch '$branch' from HEAD..."
            git worktree add -b "$branch" "$wt_path"
        fi
    fi

    # Run setup commands
    if [[ ${#WORKTREE_SETUP[@]} -gt 0 ]]; then
        info "Running setup commands..."
        for cmd in "${WORKTREE_SETUP[@]}"; do
            info "  -> $cmd"
            (cd "$wt_path" && eval "$cmd")
        done
    fi

    info "Worktree ready at: $wt_path"
    # Print path as last line to stdout (for shell wrapper to capture)
    echo "$wt_path"
}

cmd_rm() {
    local branch="${1:-}"

    if [[ -z "$branch" ]]; then
        # Try to auto-detect from current worktree
        branch="$(current_worktree_branch)" \
            || { error "Not in a worktree. Usage: git wt rm <branch>"; exit 1; }
        info "Auto-detected current worktree branch: $branch"
    fi

    local wt_path
    wt_path="$(find_worktree_path "$branch")"

    if [[ -z "$wt_path" ]]; then
        error "No worktree found for branch '$branch'"
        exit 1
    fi

    info "Removing worktree at: $wt_path"
    git worktree remove "$wt_path"
    info "Worktree removed"
}

cmd_cd() {
    if [[ $# -lt 1 ]]; then
        error "Usage: git wt cd <branch>"
        exit 1
    fi

    local branch="$1"
    local wt_path
    wt_path="$(find_worktree_path "$branch")"

    if [[ -z "$wt_path" ]]; then
        error "No worktree found for branch '$branch'"
        exit 1
    fi

    # Print only the path — shell wrapper does the actual cd
    echo "$wt_path"
}

cmd_ls() {
    git worktree list
}

cmd_init() {
    local root
    root="$(main_repo_root)"
    local conf_local="$root/worktree.conf.local"

    load_config

    if [[ -f "$conf_local" ]]; then
        warn "Existing worktree.conf.local:"
        cat "$conf_local" >&2
        echo >&2
        read -rp "Overwrite? [y/N] " answer
        if [[ "$answer" != [yY] ]]; then
            info "Aborted"
            return 0
        fi
    fi

    local default_dir="$WORKTREE_DIR"
    read -rp "Base directory for worktrees [$default_dir]: " input_dir
    input_dir="${input_dir:-$default_dir}"

    echo >&2
    info "Enter extra setup commands (one per line, empty line to finish)."
    info "Default setup: ${WORKTREE_SETUP[*]:-<none>}"
    local extra_cmds=()
    while true; do
        read -rp "  command> " cmd
        [[ -z "$cmd" ]] && break
        extra_cmds+=("$cmd")
    done

    # Build setup array
    local all_setup=()
    if [[ ${#WORKTREE_SETUP[@]} -gt 0 ]]; then
        all_setup=("${WORKTREE_SETUP[@]}")
    fi
    for cmd in "${extra_cmds[@]}"; do
        all_setup+=("$cmd")
    done

    # Write config
    {
        echo "# worktree.conf.local — personal overrides (gitignored)"
        echo "# Generated by: git wt init"
        echo ""
        if [[ "$input_dir" != "$default_dir" ]]; then
            echo "WORKTREE_DIR=\"$input_dir\""
        else
            echo "# WORKTREE_DIR=\"$input_dir\""
        fi
        echo ""
        if [[ ${#all_setup[@]} -gt 0 ]]; then
            echo "WORKTREE_SETUP=("
            for cmd in "${all_setup[@]}"; do
                echo "    \"$cmd\""
            done
            echo ")"
        fi
    } > "$conf_local"

    info "Written: $conf_local"
    cat "$conf_local" >&2
}

cmd_help() {
    cat >&2 <<'HELP'
git-wt — Git worktree helper

USAGE
    git wt <command> [args...]

COMMANDS
    add <branch> [source]   Create a worktree for <branch>.
                             If [source] is given, the new branch starts there.
    rm  [branch]            Remove a worktree. Without args, removes the
                             current worktree (auto-detected).
    cd  <branch>            Print the worktree path (use shell wrapper for cd).
    ls                      List all worktrees (git worktree list).
    init                    Interactively create worktree.conf.local.
    help, --help            Show this help.

CONFIGURATION
    Per-project config files (in repo root):
        worktree.conf           Committed project defaults.
        worktree.conf.local     Personal overrides, gitignored.

    Variables (set in config files):
        WORKTREE_DIR="..."          Base directory (default: "..")
        WORKTREE_PREFIX="..."       Directory name prefix (default: repo name)
        WORKTREE_SETUP=(...)        Commands to run after creating a worktree

    Directory naming: <base>/<prefix>-<sanitized-branch>
    Example: ../myapp-feature-login

INSTALLATION
    # Add to PATH:
    export PATH="$HOME/Projects/git-wt:$PATH"

    # Source shell wrapper for cd support:
    source ~/Projects/git-wt/git-wt.sh

    # Or use a git alias (no cd support):
    git config --global alias.wt '!git-wt'

SHELL WRAPPER (for cd support)
    Add to .zshrc / .bashrc:
        source ~/Projects/git-wt/git-wt.sh

    This defines a `wt` function:
        wt add <branch> [source]    Create worktree + cd into it
        wt cd  <branch>             cd into existing worktree
        wt rm / wt ls / wt init     Same as git wt equivalents

EXAMPLES
    git wt add feature/login master
    git wt ls
    git wt rm feature/login
    git wt init

    # With shell wrapper:
    wt add feature/login master   # creates + cd's into worktree
    wt cd feature/login           # cd into existing worktree
HELP
}

# ---------------------------------------------------------------------------
# Main dispatch
# ---------------------------------------------------------------------------
main() {
    local cmd="${1:-help}"
    shift || true

    case "$cmd" in
        add)    cmd_add "$@" ;;
        rm)     cmd_rm "$@" ;;
        cd)     cmd_cd "$@" ;;
        ls)     cmd_ls "$@" ;;
        init)   cmd_init "$@" ;;
        help|--help|-h)
                cmd_help ;;
        *)
            error "Unknown command: $cmd"
            cmd_help
            exit 1
            ;;
    esac
}

main "$@"
